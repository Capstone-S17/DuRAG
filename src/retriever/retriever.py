import weaviate.classes as wvc
import weaviate.exceptions as wvexc
from functools import reduce
from typing import Optional, Any, Literal


class Retriever:
    def __init__(self, weaviate_client, collection_name: str):
        self.client = weaviate_client
        self.collection = self.client.collections.get(collection_name)

    def _get_filter_param(
        self,
        filters: Optional[list[str]],
        mode: Optional[Literal["and", "or"]] = "or",
        property_name: Literal["content", "pdf_name", "NER"] = "pdf_name",
    ):
        """
        Generate a filter parameter based on the provided filters, mode, and property name.

        For pdf_name - use mode = "and" and do exact match (.equal)
        For content/NER - use mode = "or" and do partial match (like)

        Args:
            filters (Optional[List[str]]): A list of strings to filter on.
            mode (Literal["and", "or"]): The mode of combining filters. Defaults to "or".
            property_name (Literal["content", "pdf_name", "NER"]): The property name to filter on. Defaults to "content".

        Returns:
            wvc.query.Filter: The combined filter object according to the specified mode.
            None: If no filters are provided.

        Raises:
            ValueError: If an invalid mode is provided.
        """
        if not filters:
            return None
        try:
            if property_name == "pdf_name":
                # exact match for pdf_name
                return wvc.query.Filter.by_property(property_name).contains_any(filters)
            list_of_filters = []
            for keyword in filters:
                list_of_filters.append(
                    wvc.query.Filter.by_property(property_name).like(keyword)
                )
            if mode == "or":
                combined_filter = reduce(lambda a, b: a | b, list_of_filters)
            elif mode == "and":
                combined_filter = reduce(lambda a, b: a & b, list_of_filters)
            else:
                raise ValueError(f"Invalid mode '{mode}'. Use 'and' or 'or'.")
            return combined_filter
        except wvexc.WeaviateBaseError as e:
            # Handle potential Weaviate errors
            print(f"Error creating filter: {e}")
            return None
        except Exception as e:
            # Catch-all for any other exceptions
            print(f"Unhandled error: {e}")
            return None

    def semantic_search(
        self, query: str, filters: Optional[list[str]] = None, limit=10
    ):
        filter_param = self._get_filter_param(filters)
        return self.collection.query.near_text(
            query=query,
            # include_vector=True,
            filters=filter_param,
            limit=limit,
        )

    def full_text_search(
        self, query: str, filters: Optional[list[str]] = None, limit=10
    ):
        filter_param = self._get_filter_param(filters)
        return self.collection.query.bm25(
            query=query,
            filters=filter_param,
            limit=limit,
        )

    def hybrid_search(self, query: str, filter_params, limit=10):
        """
        filter_params: A filter object generated by _get_filter_param
        """
        return self.collection.query.hybrid(
            query=query,
            # include_vector=True,
            filters=filter_params,
            limit=limit,
        )

    @classmethod
    def chunk_text_joiner(cls, chunks: list[str]):
        """
        Joins the chunks into a single string and enumerates them. Meant to be used in RAG prompt.
        """
        return "\n".join(f"Chunk {i+1}: {chunk}" for i, chunk in enumerate(chunks))

    @classmethod
    def chunk_text_joiner_response(cls, chunks: list[Any]):
        """
        Joins the chunks into a single string and enumerates them. Works directly with the response from the retriever.
        """
        return "\n".join(
            f"Chunk {i+1}: {chunk.properties['content']}"
            for i, chunk in enumerate(chunks)
        )
