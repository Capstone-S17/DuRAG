import weaviate.classes as wvc
import weaviate.exceptions as wvexc
from functools import reduce
from typing import Optional, Any, Literal
from DuRAG.logger import logger


class Retriever:
    def __init__(self, weaviate_client, collection_name: str):
        self.client = weaviate_client
        self.collection = self.client.collections.get(collection_name)
        logger.info("Retriever initialized with collection: %s", collection_name)

    def _get_filter_param(
        self,
        filters: Optional[list[str]],
        mode: Optional[Literal["and", "or"]] = "or",
        property_name: Literal["content", "pdf_name", "NER"] = "pdf_name",
    ):
        """
        Generate a filter parameter based on the provided filters, mode, and property name.

        For pdf_name - use mode = "and" and do exact match (.equal)
        For content/NER - use mode = "or" and do partial match (like)

        Args:
            filters (Optional[List[str]]): A list of strings to filter on.
            mode (Literal["and", "or"]): The mode of combining filters. Defaults to "or".
            property_name (Literal["content", "pdf_name", "NER"]): The property name to filter on. Defaults to "content".

        Returns:
            wvc.query.Filter: The combined filter object according to the specified mode.
            None: If no filters are provided.

        Raises:
            ValueError: If an invalid mode is provided.
        """
        logger.debug("Getting filter parameter")
        if not filters:
            logger.info("No filters provided, returning None")
            return None
        try:
            if property_name == "pdf_name":
                logger.debug(
                    "Creating exact match filter for pdf_name using contains_any"
                )
                return wvc.query.Filter.by_property(property_name).contains_any(filters)
            list_of_filters = []
            for keyword in filters:
                logger.debug("Creating partial match filter for keyword: %s", keyword)
                list_of_filters.append(
                    wvc.query.Filter.by_property(property_name).like(keyword)
                )
            if mode == "or":
                logger.debug("Combining filters with OR mode")
                combined_filter = reduce(lambda a, b: a | b, list_of_filters)
            elif mode == "and":
                logger.debug("Combining filters with AND mode")
                combined_filter = reduce(lambda a, b: a & b, list_of_filters)
            else:
                logger.error("Invalid mode provided: %s", mode)
                raise ValueError(f"Invalid mode '{mode}'. Use 'and' or 'or'.")
            return combined_filter
        except wvexc.WeaviateBaseError as e:
            logger.error("Error creating filter: %s", str(e))
            return None
        except Exception as e:
            logger.error("Unhandled error: %s", str(e))
            return None

    def semantic_search(
        self, query: str, filters: Optional[list[str]] = None, limit=10
    ):
        logger.debug("Performing semantic search with query: %s", query)
        logger.debug("Filters: %s", filters)
        filter_param = self._get_filter_param(filters)
        return self.collection.query.near_text(
            query=query,
            # include_vector=True,
            filters=filter_param,
            limit=limit,
        )

    def full_text_search(
        self, query: str, filters: Optional[list[str]] = None, limit=10
    ):
        logger.debug("Performing full-text search with query: %s", query)
        logger.debug("Filters: %s", filters)
        filter_param = self._get_filter_param(filters)
        return self.collection.query.bm25(
            query=query,
            filters=filter_param,
            limit=limit,
        )

    def hybrid_search(self, query: str, filter_params, limit=10):
        """
        filter_params: A filter object generated by _get_filter_param
        """
        logger.debug("Performing hybrid search with query: %s", query)
        logger.debug("Filter parameters: %s", filter_params)
        return self.collection.query.hybrid(
            query=query,
            # include_vector=True,
            filters=filter_params,
            limit=limit,
        )

    @classmethod
    def chunk_text_joiner(cls, chunks: list[str]):
        """
        Joins the chunks into a single string and enumerates them. Meant to be used in RAG prompt.
        """
        logger.debug("Joining %d chunks of text", len(chunks))
        return "\n".join(f"Chunk {i+1}: {chunk}" for i, chunk in enumerate(chunks))

    @classmethod
    def chunk_text_joiner_response(cls, chunks: list[Any]):
        """
        Joins the chunks into a single string and enumerates them. Works directly with the response from the retriever.
        """
        logger.debug("Joining %d chunks of text from retriever response", len(chunks))
        return "\n".join(
            f"Chunk {i+1}: {chunk.properties['content']}"
            for i, chunk in enumerate(chunks)
        )
